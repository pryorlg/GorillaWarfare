using UnityEngine;

public class EnemyAttack : MonoBehaviour
{
    private Animator anim; // Varaible to store the Animator component information.

    private float attackCooldown; // Float varaible to store the attack cooldown timer.

    [SerializeField] public float startAttackCooldown; // Serialized variable so the starting time for the cooldown can be set.

    private EnemyMovement enemyMovement; // Variable that allows access to the EnemyMovement script functions.
    private EnemyHealth enemyHealth; // Variable allowing access to EnemyHealth script functions.
    
    private BoxCollider2D boxCollider; // Variable to store the boxCollider component information.

    [SerializeField] private LayerMask playerLayer; // Variable to store the playerLayer layer information.

    public Transform meleePoint; // Variable to store the child transform of the player tracking the melee point.
    public float attackRange; // Variable to store the desired radius of the attack
    [SerializeField] private int damage; // Variable to store the amount of damage given.

    private void Awake()
    {
        anim = GetComponent<Animator>(); // Stores the Animator component from the game object.
        enemyMovement = GetComponent<EnemyMovement>(); // Stores the EnemyMovement components from the EnemyMovement script
        enemyHealth = GetComponent<EnemyHealth>(); // Stores the EnemyHealth components from the script
        boxCollider = GetComponent<BoxCollider2D>(); // Stores the BoxCollider2D component from the game object.
    }

    void Update()
    {
        // If the enemy can attack and there is a player in range, then stop enemy movement,
        // set the attack animator trigger, and start the attack cooldown.
        if(canAttack() && inRange())
        {
            enemyMovement.isMoving = false;

            anim.SetTrigger("attack");

            // Begin the attack cooldown.
            attackCooldown = startAttackCooldown;
        }

        // Else, decrement the attack cooldown by time.deltaTime. When the attack cooldown
        // reaches 0, then the enemy can begin moving again.
        else
        {
            attackCooldown -= Time.deltaTime;

            if(attackCooldown <= 0)
            {
                enemyMovement.isMoving = true;
            }
        }
        
        // A ray to help debug the inRange raycast.
        Debug.DrawRay(new Vector2(boxCollider.bounds.center.x + (boxCollider.bounds.extents.x * -transform.localScale.x), boxCollider.bounds.center.y), (Vector2.right*-transform.localScale.x) * 0.5f, Color.red);
    }

    private bool inRange()
    {
        // Use the same raycast method as used in the playerMovement script. This checks if a player is 
        // within attack range.
        RaycastHit2D raycastHitPlayer = Physics2D.Raycast(
            new Vector2(boxCollider.bounds.center.x + (boxCollider.bounds.extents.x * -transform.localScale.x), 
                        boxCollider.bounds.center.y), 
                        (Vector2.right*-transform.localScale.x), 
                        0.25f, 
                        playerLayer);

        return raycastHitPlayer.collider != null;
    }

    // Check if the enemy can attack by checking whether it is alive and if the attack cooldown is
    // less than or equal to 0. 
    private bool canAttack()
    {
        return enemyHealth.isAlive() && attackCooldown <= 0;
    }

    // This function is called by an AnimationEvent 10 milliseconds into the "attack" animation.
    private void meleeAttack()
    {
        // Here we use a 2D collider array called hitPlayers to store all colliders which are within the
        // circle generated by Physics2D whenever an attack takes place. We set the center point based 
        // on the location of our sprite, set the attack range as the radius, and set the layers affected
        // to be the layer mask playerLayer.
        Collider2D[] hitPlayers = Physics2D.OverlapCircleAll(meleePoint.position, attackRange, playerLayer);

        // For each player game object within the hitPlayers 2D collider array, we call the takeDamage function
        // of the PlayerHealth script component and pass an integer to track the amount of damage given.
        foreach(Collider2D player in hitPlayers)
        {
            player.GetComponent<PlayerHealth>().takeDamage(damage);
        }
    }

    // This function allows visualization of the meleeAttack range generated by Physics2D.OverlapCircleAll()
    public void OnDrawGizmosSelected()
    {
        if (meleePoint == null){
             return;
        }

        Gizmos.DrawWireSphere(meleePoint.position, attackRange);
    }
}
